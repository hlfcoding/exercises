/*jshint node: true */

'use strict';

let {assert, log} = console;
let {atan, max, pow, sqrt, PI} = Math;

// ## 1. Multiples of 3 and 5
//
// If we list all the natural numbers below 10 that are multiples of 3 or 5,
// we get 3, 5, 6 and 9. The sum of these multiples is 23.
//
// Find the sum of all the multiples of 3 or 5 below 1000.

function triangleNumber(n) {
  return n * (n + 1) / 2;
}

function sumOfMultiplesOf3And5Below(limit) {
  // Approach 2: O(1): use triangle number formula: f(3) = 1 + 2 + 3
  let inclusiveLimit = limit - 1;
  let sum3 = 3 * triangleNumber(inclusiveLimit / 3);
  let sum5 = 5 * triangleNumber(inclusiveLimit / 5);
  let product = 3 * 5;
  let intersection = product * triangleNumber(inclusiveLimit / product);
  return parseInt(sum3 + sum5 - intersection);
}

assert(sumOfMultiplesOf3And5Below(10) == (3 + 5 + 6 + 9), 'sumOfMultiplesOf3And5Below');
//log(sumOfMultiplesOf3And5Below(1000));

// ## 2. Even Fibonacci numbers
//
// Each new term in the Fibonacci sequence is generated by adding the previous
// two terms. By starting with 1 and 2, the first 10 terms will be:
//
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
// By considering the terms in the Fibonacci sequence whose values do not exceed
// four million, find the sum of the even-valued terms.

function sumOfEvenFibonaccis(limit, debug = false) {
  let sum = 2;
  let n1 = 1;
  let n2 = 2;
  while (n1 + n2 < limit) {
    let next = n1 + n2;
    n1 = n2;
    n2 = next;
    if (n2 % 2 === 0) {
      sum += n2;
    }
  }
  if (debug) {
    log(`Largest fib within limit is ${n2}`);
  }
  return sum;
}

assert(sumOfEvenFibonaccis(34) === 10, 'sumOfEvenFibonaccis');
//log(sumOfEvenFibonaccis(4000000));

// ## 3. Largest prime factor
//
// The prime factors of 13195 are 5, 7, 13 and 29.
//
// What is the largest prime factor of the number 600851475143?
//
// > A prime number (or a prime) is a natural number greater than 1 that has no
//   positive divisors other than 1 and itself. A natural number greater than 1
//   that is not a prime number is called a composite number.

let primes = new Set();

function isPrime(n) {
  if (primes.has(n)) {
    return true;
  }
  let is = true;
  let divisor = 2;
  while (divisor <= (n / divisor)) {
    is = n % divisor !== 0;
    if (!is) { break; }
    divisor++;
  }
  if (is) {
    primes.add(n);
  }
  return is;
}

assert(isPrime(2), 'isPrime');
assert(isPrime(3), 'isPrime');
assert(!isPrime(4), 'isPrime');

function nextPrime(n) {
  let candidate = n;
  do {
    candidate++;
  } while (!isPrime(candidate));
  return candidate;
}

assert(nextPrime(29) === 31);

function largestPrimeFactor(n) {
  let prime = 1;
  let factor = 1;
  let safety = 1000;
  while (prime < (n / prime) && safety > 0) {
    safety--;
    if (safety === 0) {
      log('Being safe and not continuing!');
    }
    prime = nextPrime(prime);
    if (n % prime === 0) {
      factor = prime;
    }
  }
  return factor;
}

//log(largestPrimeFactor(600851475143));

// ## 4. Largest palindrome product
//
// A palindromic number reads the same both ways. The largest palindrome made
// from the product of two 2-digit numbers is 9009 = 91 × 99.
//
// Find the largest palindrome made from the product of two 3-digit numbers.
//
// ---
//
// Solution quadratically checks by running through first n largest possiblities
// of second factor against each n largest possibilities of first factor. Since
// the number of digits is small, we don't need to be most efficient.

function reverseString(s) {
  return s.split('').reverse().join('');
}

assert(reverseString('foo') === 'oof', 'reverse');

function isPalindrome(n) {
  let digits = (n).toString();
  if (digits.length % 2 !== 0) { return false; }
  return reverseString(digits) === digits;
}

assert(isPalindrome(9009), 'isPalindrome');
assert(!isPalindrome(123), 'isPalindrome');

function largestPalindromeFromTwoNumbersWithDigits(digits) {
  let n = parseInt('9'.repeat(digits));
  let n1 = n;
  let n2 = n;
  let product = n1 * n2;
  do {
    n2 = n;
    do {
      product = n1 * n2;
      n2--;
    } while (!isPalindrome(product) && (n2 / n) > 0.9);
    n1--;
  } while (!isPalindrome(product) && (n1 / n) > 0.9);
  return product;
}

assert(largestPalindromeFromTwoNumbersWithDigits(2) === 9009, 'largestPalindromeFromTwoNumbersWithDigits');
//log(largestPalindromeFromTwoNumbersWithDigits(3));

// ## 5. Smallest multiple
//
// 2520 is the smallest number that can be divided by each of the numbers from 1
// to 10 without any remainder.
//
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?
//
// ---
//
// The initial approach is to just have the step be the max factor. This won't
// scale for the larger range. Instead, the product of the primes in the range
// seems like a much better step, for reasons yet fully clear. Another
// optimization is to remove redundancies in the factors before checking
// divisibility.

function isDivisibleBy(n, divisors) {
  let nonDivisor = divisors.find(d => n % d !== 0);
  return nonDivisor === undefined;
}

assert(isDivisibleBy(4, [1, 2]), 'isDivisibleBy');

function createRange(length, start = 0) {
  return Array.from(new Array(length), (_, i) => i + start);
}

assert(createRange(3, 1).toString() === [1, 2, 3].toString(), 'createRange');

function smallestMultipleDivisibleByRange(range, debug = false) {
  let factors = [];
  let step = 1;
  range.reverse().forEach((n) => {
    if (isPrime(n)) {
      step *= n;
    }
    for (let i = 0, l = factors.length; i < l; i++) {
      let f = factors[i];
      if (f > n && f % n === 0) {
        return;
      }
    }
    factors.push(n);
  });
  if (debug) {
    log(`Step: ${step}, factors: ${factors}`);
  }
  let multiple = 0;
  do {
    multiple += step;
  } while (!isDivisibleBy(multiple, factors));
  return multiple;
}

assert(smallestMultipleDivisibleByRange(createRange(10, 1)) === 2520, 'smallestMultipleDivisibleByRange');
//log(smallestMultipleDivisibleByRange(createRange(20, 1)));

// ## 6. Sum square difference
//
// The sum of the squares of the first ten natural numbers is 1^2 + 2^2 + ... +
// 10^2 = 385
//
// The square of the sum of the first ten natural numbers is (1 + 2 + ... +
// 10)^2 = 55^2 = 3025
//
// Hence the difference between the sum of the squares of the first ten natural
// numbers and the square of the sum is 3025 − 385 = 2640.
//
// Find the difference between the sum of the squares of the first one hundred
// natural numbers and the square of the sum.
//
// ---
//
// This problem can simply be brute-forced. The largest number isn't that big,
// smaller than max 32-bit int.

function sumOfSquaresForRange(range) {
  return range.reduce((sum, n) => { return sum + pow(n, 2); }, 0);
}

function squareOfSumOfRange(range) {
  return pow(range.reduce((sum, n) => { return sum + n; }, 0), 2);
}

assert(sumOfSquaresForRange(createRange(10, 1)) == 385, 'sumOfSquaresForRange');
assert(squareOfSumOfRange(createRange(10, 1)) == 3025, 'squareOfSumOfRange');
assert(squareOfSumOfRange(createRange(10, 1)) - sumOfSquaresForRange(createRange(10, 1)) == 2640, 'squareOfSumOfRange - sumOfSquaresForRange');
//log(squareOfSumOfRange(createRange(100, 1)) - sumOfSquaresForRange(createRange(100, 1)));

// ## 7. 10001st prime
//
// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
// that the 6th prime is 13.
//
// What is the 10 001st prime number?
//
// ---
//
// Instead of trial division, the solution uses a rather unoptimized Sieve of
// Eratosthenes implementation, which seems to require fewer operations, about
// half. However, mutating the array while iterating seem to slow things down.

// Given a prime, go through greater numbers and remove multiples.

class SieveOfEratosthenes {

  constructor() {
    this.chunkCount = 10000;
    this.upperBound = this.chunkCount;
    this.nums = (() => {
      let nums = [2];
      for (let n = 3; n <= this.upperBound; n += 2) {
        nums.push(n);
      }
      return nums;
    })();
    this.largestPrimeIndex = 1;
  }

  get lastPrime() {
    return this.nums[this.largestPrimeIndex];
  }

  get primes() {
    return this.nums.slice(0, this.largestPrimeIndex + 1);
  }

  purgeNextMultiples() {
    this.purgeMultiplesOfPrime(this.lastPrime, this.nums);
  }

  purgeMultiplesOfPrime(p, nums) {
    let factor = p; // No need to check multiples below the square.
    function multiple() { return p * factor; }
    if (multiple() <= this.nums[0]) {
      // Scale factor up as needed (for added chunks).
      factor = this.nums[0] / multiple();
    }
    while (multiple() <= this.nums[this.nums.length - 1]) {
      let i = this.nums.indexOf(multiple());
      if (i > -1) {
        this.nums.splice(i, 1);
      }
      factor += 2;
    }
  }

  updateCursorIndex() {
    // Update the cursor on where numbers stop being guaranteed primes.
    this.largestPrimeIndex++;
    // If our cursor cannot move forward because our chunk ran out...
    if (this.largestPrimeIndex !== this.nums.length) { return; }
    // Add another chunk.
    let lowerBound = this.upperBound + 1;
    this.upperBound += this.chunkCount;
    let addition = (() => {
      let nums = [];
      for (let n = lowerBound; n <= this.upperBound; n += 2) {
        nums.push(n);
      }
      return nums;
    })();
    this.nums.forEach((p) => { this.purgeNextMultiples(p, addition); });
    this.nums.concat(addition);
  }

}

function nthPrime(ordinal) {
  // Deal with 2 as a special case.
  if (ordinal <= 1) { return 2; }
  let s = new SieveOfEratosthenes();
  while ((s.largestPrimeIndex + 1) < ordinal) {
    s.purgeNextMultiples();
    s.updateCursorIndex();
  }
  return s.lastPrime;
}

assert(nthPrime(1) === 2, 'nthPrime');
assert(nthPrime(6) === 13, 'nthPrime');
assert(nthPrime(1000) === 7919, 'nthPrime');
//log(nthPrime(10001));

// ## 8. Largest product in a series
//
// The four adjacent digits in the 1000-digit number that have the greatest
// product are 9 × 9 × 8 × 9 = 5832.
//
//     73167176531330624919225119674426574742355349194934
//     96983520312774506326239578318016984801869478851843
//     85861560789112949495459501737958331952853208805511
//     12540698747158523863050715693290963295227443043557
//     66896648950445244523161731856403098711121722383113
//     62229893423380308135336276614282806444486645238749
//     30358907296290491560440772390713810515859307960866
//     70172427121883998797908792274921901699720888093776
//     65727333001053367881220235421809751254540594752243
//     52584907711670556013604839586446706324415722155397
//     53697817977846174064955149290862569321978468622482
//     83972241375657056057490261407972968652414535100474
//     82166370484403199890008895243450658541227588666881
//     16427171479924442928230863465674813919123162824586
//     17866458359124566529476545682848912883142607690042
//     24219022671055626321111109370544217506941658960408
//     07198403850962455444362981230987879927244284909188
//     84580156166097919133875499200524063689912560717606
//     05886116467109405077541002256983155200055935729725
//     71636269561882670428252483600823257530420752963450
//
// Find the thirteen adjacent digits in the 1000-digit number that have the
// greatest product. What is the value of this product?
//
// ---
//
// Iterate the array, keeping track of the current range of adjacents. When
// range fills up, calculate the product. Update max with the product if needed.
// Upon hitting a zero or whatever's not above the minimum factor, the range
// gets cleared for next iteration. This approach should be O(n).

function maxAdjacentDigitsProductOfLength(length, digits, minimumFactor = 1) {
  let product = 0;
  let range = null;
  digits.forEach((d, i) => {
    if (d <= minimumFactor) {
      range = null; return;
    }
    if (range == null) {
      range = {start: i, end: i}; return;
    }

    range.end = i + 1; // Shift (non-inclusive) upper bound.

    if ((range.end - range.start) !== length) { return; }

    let candidate = digits.slice(range.start, range.end)
      .reduce((p, d) => { return p * d; }, 1);
    product = max(product, candidate);

    range.start += 1; // Shift lower bound.
  });
  return product;
}

let digits = [
  7,3,1,6,7,1,7,6,5,3,1,3,3,0,6,2,4,9,1,9,2,2,5,1,1,9,6,7,4,4,2,6,5,7,4,7,4,2,3,
  5,5,3,4,9,1,9,4,9,3,4,9,6,9,8,3,5,2,0,3,1,2,7,7,4,5,0,6,3,2,6,2,3,9,5,7,8,3,1,
  8,0,1,6,9,8,4,8,0,1,8,6,9,4,7,8,8,5,1,8,4,3,8,5,8,6,1,5,6,0,7,8,9,1,1,2,9,4,9,
  4,9,5,4,5,9,5,0,1,7,3,7,9,5,8,3,3,1,9,5,2,8,5,3,2,0,8,8,0,5,5,1,1,1,2,5,4,0,6,
  9,8,7,4,7,1,5,8,5,2,3,8,6,3,0,5,0,7,1,5,6,9,3,2,9,0,9,6,3,2,9,5,2,2,7,4,4,3,0,
  4,3,5,5,7,6,6,8,9,6,6,4,8,9,5,0,4,4,5,2,4,4,5,2,3,1,6,1,7,3,1,8,5,6,4,0,3,0,9,
  8,7,1,1,1,2,1,7,2,2,3,8,3,1,1,3,6,2,2,2,9,8,9,3,4,2,3,3,8,0,3,0,8,1,3,5,3,3,6,
  2,7,6,6,1,4,2,8,2,8,0,6,4,4,4,4,8,6,6,4,5,2,3,8,7,4,9,3,0,3,5,8,9,0,7,2,9,6,2,
  9,0,4,9,1,5,6,0,4,4,0,7,7,2,3,9,0,7,1,3,8,1,0,5,1,5,8,5,9,3,0,7,9,6,0,8,6,6,7,
  0,1,7,2,4,2,7,1,2,1,8,8,3,9,9,8,7,9,7,9,0,8,7,9,2,2,7,4,9,2,1,9,0,1,6,9,9,7,2,
  0,8,8,8,0,9,3,7,7,6,6,5,7,2,7,3,3,3,0,0,1,0,5,3,3,6,7,8,8,1,2,2,0,2,3,5,4,2,1,
  8,0,9,7,5,1,2,5,4,5,4,0,5,9,4,7,5,2,2,4,3,5,2,5,8,4,9,0,7,7,1,1,6,7,0,5,5,6,0,
  1,3,6,0,4,8,3,9,5,8,6,4,4,6,7,0,6,3,2,4,4,1,5,7,2,2,1,5,5,3,9,7,5,3,6,9,7,8,1,
  7,9,7,7,8,4,6,1,7,4,0,6,4,9,5,5,1,4,9,2,9,0,8,6,2,5,6,9,3,2,1,9,7,8,4,6,8,6,2,
  2,4,8,2,8,3,9,7,2,2,4,1,3,7,5,6,5,7,0,5,6,0,5,7,4,9,0,2,6,1,4,0,7,9,7,2,9,6,8,
  6,5,2,4,1,4,5,3,5,1,0,0,4,7,4,8,2,1,6,6,3,7,0,4,8,4,4,0,3,1,9,9,8,9,0,0,0,8,8,
  9,5,2,4,3,4,5,0,6,5,8,5,4,1,2,2,7,5,8,8,6,6,6,8,8,1,1,6,4,2,7,1,7,1,4,7,9,9,2,
  4,4,4,2,9,2,8,2,3,0,8,6,3,4,6,5,6,7,4,8,1,3,9,1,9,1,2,3,1,6,2,8,2,4,5,8,6,1,7,
  8,6,6,4,5,8,3,5,9,1,2,4,5,6,6,5,2,9,4,7,6,5,4,5,6,8,2,8,4,8,9,1,2,8,8,3,1,4,2,
  6,0,7,6,9,0,0,4,2,2,4,2,1,9,0,2,2,6,7,1,0,5,5,6,2,6,3,2,1,1,1,1,1,0,9,3,7,0,5,
  4,4,2,1,7,5,0,6,9,4,1,6,5,8,9,6,0,4,0,8,0,7,1,9,8,4,0,3,8,5,0,9,6,2,4,5,5,4,4,
  4,3,6,2,9,8,1,2,3,0,9,8,7,8,7,9,9,2,7,2,4,4,2,8,4,9,0,9,1,8,8,8,4,5,8,0,1,5,6,
  1,6,6,0,9,7,9,1,9,1,3,3,8,7,5,4,9,9,2,0,0,5,2,4,0,6,3,6,8,9,9,1,2,5,6,0,7,1,7,
  6,0,6,0,5,8,8,6,1,1,6,4,6,7,1,0,9,4,0,5,0,7,7,5,4,1,0,0,2,2,5,6,9,8,3,1,5,5,2,
  0,0,0,5,5,9,3,5,7,2,9,7,2,5,7,1,6,3,6,2,6,9,5,6,1,8,8,2,6,7,0,4,2,8,2,5,2,4,8,
  3,6,0,0,8,2,3,2,5,7,5,3,0,4,2,0,7,5,2,9,6,3,4,5,0
];

assert(maxAdjacentDigitsProductOfLength(4, digits) == 5832, 'maxAdjacentDigitsProductOfLength');
//log(maxAdjacentDigitsProductOfLength(13, digits));

// ## 9. Special Pythagorean triplet
//
// A Pythagorean triplet is a set of three natural numbers, a < b < c, for
// which, a^2 + b^2 = c^2. For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
//
// There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find
// the product a * b * c.
// 
// ---
//
// The solution basically brute-forces checking possible leg values by checking
// all other criteria. The one criteria not mentioned but inferrable is (right)
// triangles have additional characteristics.

function pythagoreanTripletForSum(sum) {
    let triplet;
    // Neither can be longer than the hypotenuse, and latter needs to be
    // at least half to be longest side.
    let legMax = sum / 2 - 1;
    // Go through candidates (in order) for a, b, c.
    outer:
    for (let a of createRange(legMax, 1)) { // Natural numbers start from 1.
      for (let b of createRange(legMax, (a + 1))) { // a < b
        // Sum of legs must be greater than hypotenuse to be a triangle.
        if (a + b <= sum / 2) { continue; }
        // Right triangles are such that 'leg' angles have tangent
        // relations with the legs.
        if (atan(a / b) + atan(b / a) != PI / 2) { continue; }
        // Needs to be a right triangle's hypotenuse.
        let c = sqrt(pow(a, 2) + pow(b, 2));
        if (c % 1 !== 0) { continue; }
        // Needs to fit sum.
        if (a + b + c !== sum) { continue; }
        // Commit.
        triplet = [a, b, c];
        break outer;
      }
    }
    return triplet;
}

assert(pythagoreanTripletForSum(12).toString() == [3, 4, 5].toString(), 'pythagoreanTripletForSum');
//log(pythagoreanTripletForSum(1000).reduce((s, n) => { return s * n; }, 1));
